# 참고자료
[코딩테스트](https://www.nossi.dev/cote)

[Nossi.DEV](https://www.nossi.dev/cote/tip)

# ?

# 입출력

# DP

### 정의

- **다이나믹 프로그래밍(동적 계획법)**
- **큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용**
- **기억하며 풀기(캐싱)**
- 문제해결 패러다임
- Dynamic은 별다른 의미가 없음
- 장점: **일반적인 재귀 → 동일한 작은 문제들이 여러 번 반복 되어 비효율적인 계산**

### 과정

1. **변수 파악**
    1. state 결정: 변수의 개수를 알아내기
    2. ex) **피보나치 수열:** n번째 숫자를 구하는 것→ n이 변수
2. **변수 간 관계식 = 점화식**
    1. 반복/재귀
    2. ex) 피보나치 수열: **f(n) = f(n-1) + f(n-2)**
3. **메모하기(memoization or tabulation)**
    1. **변수의 값에 따른 결과를 저장**
    2. 배열(1~3차원)
4. **기저 상태 파악**
    1. **가장 작은 문제의 상태**
    2. ex) 피보나치 수열: **f(0) = 0, f(1) = 1**
5. **구현**
    1. **Bottom-Up (Tabulation 방식) - 반복문**
    2. **Top-Down (Memoization 방식) - 재귀**

### 단서

- 최대값, 최소값
- 선택O or 선택X 가능
- 특정 조건 내 데이터를 셈
- 확률 등의 계산
- 반복적인 부분
- %연산 해서 답을 내는 문제

### 유념

- **최종 문제, 목표 기억: 상태의 어떠한 값**
- 상태와 값: 상태는 문제를 해결해 나가면서 나올수 있는 상태들. 값은 최종 결과 값과 관련있는 값
- 관계식: 시간복잡도 따지기

### 유형

- dp 2차원 배열 → 1차원으로
    - 규칙
- dp 일차원 배열형
- dp 이차원 배열형( 대각선에서 값 가져오기)
- dp 반드시 끝자리가 동일X
    - → 특정조건으로 인해서 마지막자리 0인 경우와 1인 경우로 나눌 수 있는데 1인 경우 항상 01 이 돼서 0인 경우 01인 경우로 나눠볼 수도 있다!

[2193번: 이친수](https://www.acmicpc.net/problem/2193)

- 전단계 뿐만 아니라 전전 단계 고려 가능
- 규칙이 안보이면 예시 단계 높이기
    - 제외: 반드시 아닌 것

### 문제

- LCS(Longest Common Subsequence, 최장 공통 부분 수열)
- 배낭 문제
- 구간합(누적합)
- 위상정렬
    
    [2056번: 작업](https://www.acmicpc.net/problem/2056)
    

### **Divide and Conquer(분할 정복)와 차이점**

- 공통점: **주어진 문제를 작게 쪼개서 하위 문제로 큰 문제 해결**.
- 차이점: 부분 문제 **중복** 여부

# **분할 정복**

- **Divide and Conquer**
- 탐색 공간을 특정 기준에 따라 나누고, 나눈 각 탐색 공간에서 탐색을 이어나감
- ex) 이진 탐색

# 백트래킹

- 다시 돌아가서 추적
- 어떤 노드의 '유망성'을 판단한 뒤, 해당 노드가 유망하지 않다면 부모 노드로 돌아가 다른 자식 노드를 찾는 방법
- 해를 찾는 도중에 막히면 더 이상 깊이 들어가지 않고, 이전 단계로 되돌아가서 해를 찾아나가는 기법

### 단서

- 최적화 문제
- 결정 문제
- 변수 제한이(n) 크지 않음
- 수열, 조합 - 규칙이 있고 중간에 연산을 그만두고 다음 거 하고 싶을 때
- 부분집합
- “여러 경로의 최댓값”
- 이동 횟수가 한 가지로 고정됨 (깊이 설정 가능)

DFS VS 백트래킹

- DFS: 불필요할 거 같은 경로를 사전에 차단하지 않기 때문에 **경우의 수를 최적으로 줄이지 못한다 = 가능한 모든 경로(후보)를 탐색**
- 백트래킹: **가지치기 = 해를 찾아가는 도중에 지금의 경로가 해가 될 거 같지 않으면, 더 이상 깊이 들어가지 않고 이전 단계로 다시 돌아간다**

### 변수설정

1. visit[]: 자기 자신을 포함하지 않기 위함
    1. 특정 노드 제외
2. dfs(at,depth) 에서 at: 더 깊은 깊이로 들어간 재귀 내 반복문에서 시작위치를 직접 지정하기 위함 
    1. 특정 인덱스 이상/이하 제외 

- 순열
    - arr[] : 그때 줄의 값을 저장할 배열
    - visit[] : 노드 방문 체크할 배열. 재귀 바로 후에 다시 방문하지 않은 상태로 변경(자식노드 방문이 끝나면): 특정 노드만 안쓰려고  할 때
- 조합
    - arr[] : 그때 줄의 값 저장.
    - dfs(at, depth)로 구성 : at위치 이상부터만 쓰려고 할 때

### 구조

```java

dfs(?,조건 변수){
	if 끝내는 조건  //1. 자식 탈출 조건 = 유망성 판단 
		//업데이트
		return // return 안해주면 밑에서 i 인덱스 사용시 마지막에 인덱스 범위 넘는 수 있음
	

	for(i n번) //2. 반복
		visit[] = true //3. 방문 처리
		dfs 재귀호출 //4. 재귀
		visit[] = false //5. 미방문 처리

}

```

- 이항 정리
    - nC0, nC1, … ,nCn의 모든 경우 살펴봄(선택과 미선택)
    - O(2^n)

```java
private static void dfs(int at, int sum) {
     if(at == n){
				//조건 
	     return;
     }

     dfs(at+1, sum + num[at]); // 값 포함
     dfs(at+1, sum); // 값 미포함

 }
```

- 2차원 배열 → 일차원 배열(인덱스는 열, 담긴 값은 행)(boj **N-Queen 문제)**

```java
private static void dfs(int depth) {
     // depth가 n번 열까지 도달해 모든 퀸을 놓았다면
     if(depth ==n){
         cnt++; //그러니 cnt 올려준다
         return;
     }
     for(int i=0; i<n; i++){ //모든 행을 돈다
         arr[depth] = i; //depth열의 i번째 행
         //3. 유망성 판단
         if(possible(depth)){ // 놓을 수 있는 위치면
             dfs(depth +1); // 다음 열로 갈 것
         }
     }
 }
```

### 주의

- 가능성 제한 if문에서 return 빼먹지 말기!!!!

# 완전 탐색

# 그래프

### 단서

- 그리드

### 효율화

- map이 이진값(2개의 상태)일 경우에는 visit 배열이 필요없다.
    - map의 상태를 바로 바꿔주면 되고, **visit대신 map 상태로 방문처리.**

# 최단거리

### 다익스트라

- 가중치가 1이 아니고 음의 가중치를 갖는 간선이 없는 경우
- O((V + E) log V)

### 벨만-포드

- O(V * E)

### 플로이드-워셜

- 그래프에서 여러 노드를 거쳐갈 때 최소 값
- 가중치 있든 없든 모두 적용 가능
- O(V^3)
    - V 작을 때 사용 가능

[1389번: 케빈 베이컨의 6단계 법칙](https://www.acmicpc.net/problem/1389)

# BFS

### 단서

- 두가지 선택 가능한 탐색
- **여러 경로의 최솟값**(비용)
    - 최단 경로
    - 최소 시간
- 여러 경로의 최단 경로
    - 최단 경로는 큐의 깊이로 판단 가능. **여러 경로**는 큐가 빌때까지 돌리는 반복문 안의 반복문으로 구현한다.
    - 이때 cnt[] 배열을 만들어서 dp질 하면 각 경로의 깊이 저장 됨

### 참고

- bfs 한번에 up, down과 같이 2개 이상 탐색 가능
    - 엘베 문제
    - 상하좌우 이동 문제
- visit 배열 필요 없고 map자체로 visit 처리 가능(boj 4963 **섬의 개수)**

### 구조

```java
q.offer() // 1. 큐에 맨처음 삽입

while(!q.isEmpty()) // 2. bfs 들어감 
	변수 = q.poll() // 3. 큐에서 뺌

	//4. 조건

	q.offer()  // 5. 큐에 삽입

```

# DFS

### 단서

- **여러 경로의 최댓값**
- 재귀적
- 선택 미선택
- 제한 길이 고정( → depth로 끊어주기)
- 탐색 공간 제한
- 탐색 공간 내 탐색 목표가 있음
- 전이할 수 있는 상태 존재

### 유형

- 이전상태와 다음상태 변화 체크

### 참고

- 재귀적으로 반복할 때 쓰이는 변수에 대해선 아예 초기에 인수로 세팅해주기.(전역 변수보다 나은 선택)

# 이분탐색

- **정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법**
- 업다운 게임

### 설명

- 시작 인덱스 = 0, 끝 인덱스 =n, 목표 값 = target, 중간 인덱스 = mid
- 시작 위치와 끝 위치가 같거나 끝위치가 더 클때 반복
    1. 중간값 설정 1) 홀수 2)짝수 → 다( end+start) / 2 로 중간 위치 만들 수 있다.
    2. if mid 위치 데이터 값 = 목표 값 → 찾음
    3. if mid 위치 데이터 값이 목표 값보다 큼 → 왼쪽 부분 남기기 
        - end = mid -1
    4. if mid 위치 데이터 값이 목표 값보다 작음 → 오른쪽 부분 남기기 
        - start = mid +1

### 단서

- 전체를 탐색하기엔 너무 많을 때
- **정렬**되어 있을 때
- **단조증가,** 정렬, 배열
- 문제조건에 2^(31)-1 처럼 너무 큰 숫자 조건 나옴
- **잘라서 버리기**
    - 제한 값(특정 조건)을 두고 탐색(효율을 위해 이진탐색)하게 만듦

### 참고

- 조건문에 꼭 start와 end가 포함되지 않아도 됨(다른 조건으로 대치 가능)
- 정렬안되어 있을 때 꼭 정렬할 필요 없음. 최댓값만 구하면 되는 경우 많음
- 웬만해서 범위가 크니까 long으로 변수 선언하는 게 좋을듯

### 구현

변수 3개(`start, end, mid`)를 사용하여 탐색

1. 반복문

```
int bSearchLoop(int n, int target)
{
    int start = 0;
    int end = n;
    int mid;
    while (end >= start)
    {
        mid = (end + start) / 2;
        if (arrN[mid] == target)
            return 1;
        else if (arrN[mid] > target)
            end = mid - 1;
        else
            start = mid + 1;
    }
    return 0;
}
```

1. 재귀

```
int bSearchRec(int low, int high, int target)
{
    if (low > high)
        return 0;
    int mid = (low + high) / 2;
    if (arrN[mid] == target)
        return 1;
    else if (arrN[mid] > target)
        return bSearchRec(low, mid - 1, target);
    else
        return bSearchRec(mid + 1, high, target);
}
```

# 다익스트라

### 구조

- Node를 만들어서 다음 노드의 번호(end), 간선의 가중치(weight) 저장
- `PriorityQueue` 를 이용한 bfs (가중치 기준 정렬) - 응용 문제서 시간 단축 가능
- 현재 정점 방문 x → 방문처리
    - 다음 정점 방문 x && 현재 정점 dp값 + 다음 가중치 값 < 다음 정점 dp값 이면
        - 방문처리
        - 다음 정점 dp 값을 갱신
        - 큐에 넣고 다음으로

### 단서

- 가중치(음이 아님)
- 최소값

# 해시테이블/문자열

### 구조

- map을 사용해 저장, 검색
    - hash map
        - 평균 O(1), 최악 O(n)
    - TreeMap: 키를 기준으로 정렬된 순서로 출력할 때 (반복시)
        - O(logn)
        - 메모리 오버헤드가 더 높고 null 키 X

### 단서

- 키

# 위상정렬

### 단서

- 선행 조건, 사이클 존재여부 확인

# 시뮬레이션/구현

### 접근

1. 디버깅
2. 문제 도식화

# 스택

### 유형

- 괄호 문제

### 단서

- last in first out

# 큐

# 우선순위 큐

### 시간복잡도

- 추가: O(logn)
- 우선순위 가장 높은 원소 확인: O(1)
- 우선순위 가장 높은 원소 제거: O(logn)

(배열은 O(1), O(n) , O(n))

### 유형

- 운영체제 - 시간의 흐름에 따라 우선순위 정해야 하는 원소 달라짐

### 단서

- 추가할 때마다 정렬은 nlogn 이니까 비쌈 - 배열보다 빠른 것이 필요할 때
- 최소 힙

# 비트마스크

- 나중에 풀어보기

[14391번: 종이 조각](https://www.acmicpc.net/problem/14391)
